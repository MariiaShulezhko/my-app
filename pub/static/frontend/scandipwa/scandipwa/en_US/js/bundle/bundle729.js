require.config({"config": {
        "jsbuild":{"Magento_Tinymce3/tiny_mce/classes/util/Quirks.js":"(function(tinymce) {\n\tvar VK = tinymce.VK, BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE;\n\n\t/**\n\t * Fixes a WebKit bug when deleting contents using backspace or delete key.\n\t * WebKit will produce a span element if you delete across two block elements.\n\t *\n\t * Example:\n\t * <h1>a</h1><p>|b</p>\n\t *\n\t * Will produce this on backspace:\n\t * <h1>a<span class=\"Apple-style-span\" style=\"<all runtime styles>\">b</span></p>\n\t *\n\t * This fixes the backspace to produce:\n\t * <h1>a|b</p>\n\t *\n\t * See bug: https://bugs.webkit.org/show_bug.cgi?id=45784\n\t *\n\t * This code is a bit of a hack and hopefully it will be fixed soon in WebKit.\n\t */\n\tfunction cleanupStylesWhenDeleting(ed) {\n\t\tvar dom = ed.dom, selection = ed.selection;\n\n\t\ted.onKeyDown.add(function(ed, e) {\n\t\t\tvar rng, blockElm, node, clonedSpan, isDelete;\n\n\t\t\tisDelete = e.keyCode == DELETE;\n\t\t\tif (isDelete || e.keyCode == BACKSPACE) {\n\t\t\t\te.preventDefault();\n\t\t\t\trng = selection.getRng();\n\n\t\t\t\t// Find root block\n\t\t\t\tblockElm = dom.getParent(rng.startContainer, dom.isBlock);\n\n\t\t\t\t// On delete clone the root span of the next block element\n\t\t\t\tif (isDelete)\n\t\t\t\t\tblockElm = dom.getNext(blockElm, dom.isBlock);\n\n\t\t\t\t// Locate root span element and clone it since it would otherwise get merged by the \"apple-style-span\" on delete/backspace\n\t\t\t\tif (blockElm) {\n\t\t\t\t\tnode = blockElm.firstChild;\n\n\t\t\t\t\t// Ignore empty text nodes\n\t\t\t\t\twhile (node && node.nodeType == 3 && node.nodeValue.length == 0)\n\t\t\t\t\t\tnode = node.nextSibling;\n\n\t\t\t\t\tif (node && node.nodeName === 'SPAN') {\n\t\t\t\t\t\tclonedSpan = node.cloneNode(false);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Do the backspace/delete actiopn\n\t\t\t\ted.getDoc().execCommand(isDelete ? 'ForwardDelete' : 'Delete', false, null);\n\n\t\t\t\t// Find all odd apple-style-spans\n\t\t\t\tblockElm = dom.getParent(rng.startContainer, dom.isBlock);\n\t\t\t\ttinymce.each(dom.select('span.Apple-style-span,font.Apple-style-span', blockElm), function(span) {\n\t\t\t\t\tvar bm = selection.getBookmark();\n\n\t\t\t\t\tif (clonedSpan) {\n\t\t\t\t\t\tdom.replace(clonedSpan.cloneNode(false), span, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdom.remove(span, true);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Restore the selection\n\t\t\t\t\tselection.moveToBookmark(bm);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * WebKit and IE doesn't empty the editor if you select all contents and hit backspace or delete. This fix will check if the body is empty\n\t * like a <h1></h1> or <p></p> and then forcefully remove all contents.\n\t */\n\tfunction emptyEditorWhenDeleting(ed) {\n\t\ted.onKeyUp.add(function(ed, e) {\n\t\t\tvar keyCode = e.keyCode;\n\n\t\t\tif (keyCode == DELETE || keyCode == BACKSPACE) {\n\t\t\t\tif (ed.dom.isEmpty(ed.getBody())) {\n\t\t\t\t\ted.setContent('', {format : 'raw'});\n\t\t\t\t\ted.nodeChanged();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * WebKit on MacOS X has a weird issue where it some times fails to properly convert keypresses to input method keystrokes.\n\t * So a fix where we just get the range and set the range back seems to do the trick.\n\t */\n\tfunction inputMethodFocus(ed) {\n\t\ted.dom.bind(ed.getDoc(), 'focusin', function() {\n\t\t\ted.selection.setRng(ed.selection.getRng());\n\t\t});\n\t};\n\n\t/**\n\t * Backspacing in FireFox/IE from a paragraph into a horizontal rule results in a floating text node because the\n\t * browser just deletes the paragraph - the browser fails to merge the text node with a horizontal rule so it is\n\t * left there. TinyMCE sees a floating text node and wraps it in a paragraph on the key up event (ForceBlocks.js\n\t * addRootBlocks), meaning the action does nothing. With this code, FireFox/IE matche the behaviour of other\n     * browsers\n\t */\n\tfunction removeHrOnBackspace(ed) {\n\t\ted.onKeyDown.add(function(ed, e) {\n\t\t\tif (e.keyCode === BACKSPACE) {\n\t\t\t\tif (ed.selection.isCollapsed() && ed.selection.getRng(true).startOffset === 0) {\n\t\t\t\t\tvar node = ed.selection.getNode();\n\t\t\t\t\tvar previousSibling = node.previousSibling;\n\t\t\t\t\tif (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === \"hr\") {\n\t\t\t\t\t\ted.dom.remove(previousSibling);\n\t\t\t\t\t\ttinymce.dom.Event.cancel(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t/**\n\t * Firefox 3.x has an issue where the body element won't get proper focus if you click out\n\t * side it's rectangle.\n\t */\n\tfunction focusBody(ed) {\n\t\t// Fix for a focus bug in FF 3.x where the body element\n\t\t// wouldn't get proper focus if the user clicked on the HTML element\n\t\tif (!Range.prototype.getClientRects) { // Detect getClientRects got introduced in FF 4\n\t\t\ted.onMouseDown.add(function(ed, e) {\n\t\t\t\tif (e.target.nodeName === \"HTML\") {\n\t\t\t\t\tvar body = ed.getBody();\n\n\t\t\t\t\t// Blur the body it's focused but not correctly focused\n\t\t\t\t\tbody.blur();\n\n\t\t\t\t\t// Refocus the body after a little while\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tbody.focus();\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n\t * WebKit has a bug where it isn't possible to select image, hr or anchor elements\n\t * by clicking on them so we need to fake that.\n\t */\n\tfunction selectControlElements(ed) {\n\t\ted.onClick.add(function(ed, e) {\n\t\t\te = e.target;\n\n\t\t\tif (/^(IMG|HR)$/.test(e.nodeName))\n\t\t\t\ted.selection.select(e);\n\n\t\t\tif (e.nodeName == 'A' && ed.dom.hasClass(e, 'mceItemAnchor'))\n\t\t\t\ted.selection.select(e);\n\n\t\t\ted.nodeChanged();\n\t\t});\n\t};\n\n\t/**\n\t * Fire a nodeChanged when the selection is changed on WebKit this fixes selection issues on iOS5. It only fires the nodeChange\n\t * event every 50ms since it would other wise update the UI when you type and it hogs the CPU.\n\t */\n\tfunction selectionChangeNodeChanged(ed) {\n\t\tvar lastRng, selectionTimer;\n\n\t\ted.dom.bind(ed.getDoc(), 'selectionchange', function() {\n\t\t\tif (selectionTimer) {\n\t\t\t\tclearTimeout(selectionTimer);\n\t\t\t\tselectionTimer = 0;\n\t\t\t}\n\n\t\t\tselectionTimer = window.setTimeout(function() {\n\t\t\t\tvar rng = ed.selection.getRng();\n\n\t\t\t\t// Compare the ranges to see if it was a real change or not\n\t\t\t\tif (!lastRng || !tinymce.dom.RangeUtils.compareRanges(rng, lastRng)) {\n\t\t\t\t\ted.nodeChanged();\n\t\t\t\t\tlastRng = rng;\n\t\t\t\t}\n\t\t\t}, 50);\n\t\t});\n\t}\n\n\t/**\n\t * Screen readers on IE needs to have the role application set on the body.\n\t */\n\tfunction ensureBodyHasRoleApplication(ed) {\n\t\tdocument.body.setAttribute(\"role\", \"application\");\n\t}\n\n\ttinymce.create('tinymce.util.Quirks', {\n\t\tQuirks: function(ed) {\n\t\t\t// WebKit\n\t\t\tif (tinymce.isWebKit) {\n\t\t\t\tcleanupStylesWhenDeleting(ed);\n\t\t\t\temptyEditorWhenDeleting(ed);\n\t\t\t\tinputMethodFocus(ed);\n\t\t\t\tselectControlElements(ed);\n\n\t\t\t\t// iOS\n\t\t\t\tif (tinymce.isIDevice) {\n\t\t\t\t\tselectionChangeNodeChanged(ed);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// IE\n\t\t\tif (tinymce.isIE) {\n\t\t\t\tremoveHrOnBackspace(ed);\n\t\t\t\temptyEditorWhenDeleting(ed);\n\t\t\t\tensureBodyHasRoleApplication(ed);\n\t\t\t}\n\n\t\t\t// Gecko\n\t\t\tif (tinymce.isGecko) {\n\t\t\t\tremoveHrOnBackspace(ed);\n\t\t\t\tfocusBody(ed);\n\t\t\t}\n\t\t}\n\t});\n})(tinymce);\n"}
}});
