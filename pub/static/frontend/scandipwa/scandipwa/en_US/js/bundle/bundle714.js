require.config({"config": {
        "jsbuild":{"Magento_Tinymce3/tiny_mce/classes/ui/Control.js":"/**\n * Control.js\n *\n * Copyright 2009, Moxiecode Systems AB\n * Released under LGPL License.\n *\n * License: http://tinymce.moxiecode.com/license\n * Contributing: http://tinymce.moxiecode.com/contributing\n */\n\n(function(tinymce) {\n\t// Shorten class names\n\tvar DOM = tinymce.DOM, is = tinymce.is;\n\n\t/**\n\t * This class is the base class for all controls like buttons, toolbars, containers. This class should not\n\t * be instantiated directly other controls should inherit from this one.\n\t *\n\t * @class tinymce.ui.Control\n\t */\n\ttinymce.create('tinymce.ui.Control', {\n\t\t/**\n\t\t * Constructs a new control instance.\n\t\t *\n\t\t * @constructor\n\t\t * @method Control\n\t\t * @param {String} id Control id.\n\t\t * @param {Object} s Optional name/value settings object.\n\t\t */\n\t\tControl : function(id, s, editor) {\n\t\t\tthis.id = id;\n\t\t\tthis.settings = s = s || {};\n\t\t\tthis.rendered = false;\n\t\t\tthis.onRender = new tinymce.util.Dispatcher(this);\n\t\t\tthis.classPrefix = '';\n\t\t\tthis.scope = s.scope || this;\n\t\t\tthis.disabled = 0;\n\t\t\tthis.active = 0;\n\t\t\tthis.editor = editor;\n\t\t},\n\t\t\n\t\tsetAriaProperty : function(property, value) {\n\t\t\tvar element = DOM.get(this.id + '_aria') || DOM.get(this.id);\n\t\t\tif (element) {\n\t\t\t\tDOM.setAttrib(element, 'aria-' + property, !!value);\n\t\t\t}\n\t\t},\n\t\t\n\t\tfocus : function() {\n\t\t\tDOM.get(this.id).focus();\n\t\t},\n\n\t\t/**\n\t\t * Sets the disabled state for the control. This will add CSS classes to the\n\t\t * element that contains the control. So that it can be disabled visually.\n\t\t *\n\t\t * @method setDisabled\n\t\t * @param {Boolean} s Boolean state if the control should be disabled or not.\n\t\t */\n\t\tsetDisabled : function(s) {\n\t\t\tif (s != this.disabled) {\n\t\t\t\tthis.setAriaProperty('disabled', s);\n\n\t\t\t\tthis.setState('Disabled', s);\n\t\t\t\tthis.setState('Enabled', !s);\n\t\t\t\tthis.disabled = s;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Returns true/false if the control is disabled or not. This is a method since you can then\n\t\t * choose to check some class or some internal bool state in subclasses.\n\t\t *\n\t\t * @method isDisabled\n\t\t * @return {Boolean} true/false if the control is disabled or not.\n\t\t */\n\t\tisDisabled : function() {\n\t\t\treturn this.disabled;\n\t\t},\n\n\t\t/**\n\t\t * Sets the activated state for the control. This will add CSS classes to the\n\t\t * element that contains the control. So that it can be activated visually.\n\t\t *\n\t\t * @method setActive\n\t\t * @param {Boolean} s Boolean state if the control should be activated or not.\n\t\t */\n\t\tsetActive : function(s) {\n\t\t\tif (s != this.active) {\n\t\t\t\tthis.setState('Active', s);\n\t\t\t\tthis.active = s;\n\t\t\t\tthis.setAriaProperty('pressed', s);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Returns true/false if the control is disabled or not. This is a method since you can then\n\t\t * choose to check some class or some internal bool state in subclasses.\n\t\t *\n\t\t * @method isActive\n\t\t * @return {Boolean} true/false if the control is disabled or not.\n\t\t */\n\t\tisActive : function() {\n\t\t\treturn this.active;\n\t\t},\n\n\t\t/**\n\t\t * Sets the specified class state for the control.\n\t\t *\n\t\t * @method setState\n\t\t * @param {String} c Class name to add/remove depending on state.\n\t\t * @param {Boolean} s True/false state if the class should be removed or added.\n\t\t */\n\t\tsetState : function(c, s) {\n\t\t\tvar n = DOM.get(this.id);\n\n\t\t\tc = this.classPrefix + c;\n\n\t\t\tif (s)\n\t\t\t\tDOM.addClass(n, c);\n\t\t\telse\n\t\t\t\tDOM.removeClass(n, c);\n\t\t},\n\n\t\t/**\n\t\t * Returns true/false if the control has been rendered or not.\n\t\t *\n\t\t * @method isRendered\n\t\t * @return {Boolean} State if the control has been rendered or not.\n\t\t */\n\t\tisRendered : function() {\n\t\t\treturn this.rendered;\n\t\t},\n\n\t\t/**\n\t\t * Renders the control as a HTML string. This method is much faster than using the DOM and when\n\t\t * creating a whole toolbar with buttons it does make a lot of difference.\n\t\t *\n\t\t * @method renderHTML\n\t\t * @return {String} HTML for the button control element.\n\t\t */\n\t\trenderHTML : function() {\n\t\t},\n\n\t\t/**\n\t\t * Renders the control to the specified container element.\n\t\t *\n\t\t * @method renderTo\n\t\t * @param {Element} n HTML DOM element to add control to.\n\t\t */\n\t\trenderTo : function(n) {\n\t\t\tDOM.setHTML(n, this.renderHTML());\n\t\t},\n\n\t\t/**\n\t\t * Post render event. This will be executed after the control has been rendered and can be used to\n\t\t * set states, add events to the control etc. It's recommended for subclasses of the control to call this method by using this.parent().\n\t\t *\n\t\t * @method postRender\n\t\t */\n\t\tpostRender : function() {\n\t\t\tvar t = this, b;\n\n\t\t\t// Set pending states\n\t\t\tif (is(t.disabled)) {\n\t\t\t\tb = t.disabled;\n\t\t\t\tt.disabled = -1;\n\t\t\t\tt.setDisabled(b);\n\t\t\t}\n\n\t\t\tif (is(t.active)) {\n\t\t\t\tb = t.active;\n\t\t\t\tt.active = -1;\n\t\t\t\tt.setActive(b);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Removes the control. This means it will be removed from the DOM and any\n\t\t * events tied to it will also be removed.\n\t\t *\n\t\t * @method remove\n\t\t */\n\t\tremove : function() {\n\t\t\tDOM.remove(this.id);\n\t\t\tthis.destroy();\n\t\t},\n\n\t\t/**\n\t\t * Destroys the control will free any memory by removing event listeners etc.\n\t\t *\n\t\t * @method destroy\n\t\t */\n\t\tdestroy : function() {\n\t\t\ttinymce.dom.Event.clear(this.id);\n\t\t}\n\t});\n})(tinymce);"}
}});
